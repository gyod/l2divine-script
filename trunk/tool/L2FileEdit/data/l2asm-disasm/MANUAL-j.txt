
1 - DDFファイルフォーマット
2 - 文字変換
3 - コマンドオプション

------------------------------------------------------------------------
1) DDFファイルフォーマット

これらのファイルはl2disasmとl2asmがL2のdatファイルを扱うために解釈する方法を定義するために使用されます。DDFファイルは「dat definition file」の略で、l2disasmとl2asmで共通です。また、そのフォーマットは、C言語と少し似ています。

a) コメント

次のようなCやC99やシェルスクリプトに似たコメントが使用可能です。
/* ... */、 //、#

b) クォート

クォートを解釈する機能を実装していますが、グローバル変数FS（下記参照）以外には使用されません。

c) 特殊リテラル

NO = 0
YES = 1
OFF = -1

l2disasmとl2asmはこれらについて常に数値として解釈します。

d) 制御変数

これらはプログラムの全体の動作を制御します。常にDDFファイルの先頭に指定します。

d.1) FS

デフォルト：
FS = "\t";

FSは（sedのように）それぞれの項目の区切り文字です。どのような文字でも使用可能です。\tはタブ文字を表しています。他に\xはxをクォートします。

L2asmはこのフィールドを無視し常にフィールドの区切りとしてタブ文字を期待するので、覚えておいてください。

d.2) RECCNT

デフォルト：
RECCNT = OFF;

RECCNTはフィールド数を指定するために使用される変数です。ほんのわずかなもの（例えばchargrp.dat）を除くすべてのDATファイルは、暗黙のうちにこの情報を含んでいます。

L2disasmは明示的にRECCNT行だけを読みこみ、DATファイルに格納されたカウンタを使用できないことを前提としています。
L2asmは、コンパイルされたファイルにRECCNTの設定値を書き込むことはありません。

d.3) MTXCNT_OUT, MATCNT_OUT

デフォルト：
MTXCNT_OUT = YES;
MATCNT_OUT = YES;

この論理変数はMTX/MTX2/MTX3とMAT/MAT2の入り混じったデータのカウンターの出力を制御します。エクスポートされたファイルの見た目に効果があります。

L2asmはこれらのフィールドを無視し、暗黙的にYESに設定されていると仮定します。

d.4) ORD_IGNORE

デフォルト：
ORD_IGNORE = NO;

l2disasmが直前のフィールドであるORDプロパティを無視するかどうかを制御する変数です。
L2asmは常に直前のフィールドであるORDプロパティとこの制御変数を無視します。

d.5) HEADER

デフォルト：
HEADER = YES;

L2disasmは最初の行を項目名とするべきかどうか決定するために使用します。
L2asmは最初の行を項目名とするかどうか決定するために使用します。

d.6) MAGIC

デフォルト：
MAGIC = 0;

ファイルの最後に現れる異常なDWORDのサイズ。現在これを使用しているdatファイルはありません。

L2disasmはこのフィールドを無視します（何も出力しません）。
L2asmは最後のSafePackageマーカーの直前にマジック0を書き込みます。

e) ddf本体部分

DDFファイルの本体は、次のようになります：

{
        UINT ID;
        UINT val1;
        UINT val_enb;
        UINT cnt;
        ASCF str1;
                ORD = 1;
        UINT val2[10];
                SKIPIF = [(1, 3), (4 .. 8, -4 .. -2)];
        ASCF str2;
        ASCF str3;
                CNTR cntc;
                UINT tabc[cntc];
        CHAR c;
        UINT val3[val1];
                SOFT = 4;
        MTX tab[cnt];
                SOFT = 4;
                SOFTM = 2;
                SOFTT = 3;
                ENBBY = [(val_enb,1)];
                ENBBY = [(val_enb:2,2),(val1,3)];
        FILLER void{50};
        MTX3 arrwtf;
}

各フィールドは型と項目名で構成されています。さらに、各フィールドは追加のプロパティを持つことができます。

e.1) 型（type）

型は次のいずれか（丸括弧内はCの対応型）である必要があります：

UINT (uint32_t)
HEX (uint32_t 16進表示)
INT (int32_t)
UWORD (uint16_t)
WORD (int16_t)
UCHAR (uint8_t)
CHEX (uint8_t 16進表示)
CHAR (int8_t)
FLOAT (float)
UNICODE
ASCF
MAT
MAT2
MTX
MTX2
MTX3
FILLER
CNTR

ASCFは、datファイルで一般的に使用されるasciiまたはunicodeを特定した形式です。（直前に1バイトのサイズを伴う）
UNICODEは、文字列の前にint型のサイズを伴うプレーンunicodeです。
FLOATは、NaN値を保存またはエンコードして戻すことができます。NaN（0xX）形式を使用しており、
        Xはフロートの任意の16進数値（32ビット）に置き換えられます。
これらはどちらも他から強制されない限りUTF-8で記述されます - 詳細はセクション2を参照してください。

CNTRは特殊な1バイト以上の「パックされた」カウンターです（同一のカウンタは内部的にASCFで使用されています）。

他のフィールドのように記述することができます：

MTX {
        INT cntm;
        UNICODE mesh[cntm];
        INT cntt;
        UNICODE text[cntt];
}

MTX2 {
        INT cntm;
        {
                UNICODE mesh;
                UINT val1;
                UCHAR val2;
        } submtx[cntm]
        INT cntt;
        UNICODE text[cntt];
}

MTX3 {
        INT cntm;
        {
                UNICODE mesh;
                UCHAR val[2];
        } submtx[cntm]
        INT cntt;
        UNICODE text[cntt];
        UNICODE textext;
}

MAT {
        INT cnt;
        {
                INT id;
                INT val;
        } mats[cnt];
}

MAT2 {
        INT cnt;
        INT extra;
        {
                INT id;
                INT val;
        } mats[cnt];
}

e.2) 項目名（ident）

項目名は数値以外の文字から始まっていなければなりません。以下を除く文字から構成されます：

スペース文字 [](){}=,/*\#:;

項目名の後のテーブルを表す角括弧（[]）は、直接数値により（静的テーブルとします）、または他のフィールドの名前により（動的テーブルとします）制御できるカウンタです。後者の場合、フィールドは数値型でなければなりません。一次元のテーブルのみ使用可能です。

FILLER型は、通常のテーブルと区別するために中括弧（{}）を使用しています。{cnt}バイト分を事前に定義済みの値で埋めます。復号化されたファイル内のフォームカウンターか値の1つの項目のみ使用します。FILLERはテーブルにすることはできません - 例えば、FILLER dat{10}[10]という記述は許されません（またどの方法も無意味です）。

e.3) プロパティ（properties）

すべてのフィールドは以下のようなプロパティを持つことができます：

ENBBYは、現在の項目を他のフィールド（整数型のみ）で有効化するかどうか制御します。これは主にweapongrp.datための機能です - 両手武器のため多くのフィールドを持っています。以下の例では、MTX型の動的テーブル「tab」は、( val_enb == 1 || ( (val_enb & 2) == 2 && val1 == 3 ) )（動作をC言語で表記）を満たす場合のみ、datファイルから読み込まれます。参照する項目名に続けてコロンを使用すると、右側にビットマスクを指定できます。参照されるフィールドがテーブルの場合は、テーブルの最初の要素と比較演算されます。

        MTX tab[cnt];
                ENBBY = [(val_enb,1)];
                ENBBY = [(val_enb:2,2),(val1,3)];

ORDは、順序を制御します。 ORD == OFF はl2disasmに項目全体を全く出力させなくします。整数は相対的な順序を設定します。残りのフィールドは最後まで既定の順序で書かれます。前述した最初のORD_IGNORE変数で全体的にカスタムオーダーを無効にすることができます。 L2asmはORDプロパティと制御変数を両方とも無視します。並べ替えは安定していています（同じORD値の場合は、元の順序が保持されます）。

SKIPIFは、その値に応じて項目のデータの出力をスキップするために使用されます。以下の例を見てください：

        UINT val2[10];
                SKIPIF = [(1, 3), (4 .. 8, -4 .. -2)];

このような場合に、val2の特定の値は空の文字列として出力されます：

val2[1]が3である
val2[4]からval[8]までの値が[-4 .. -2]（-4から-2）に一つでも該当する

floatフィールドには浮動小数点の範囲を、integerィールドには整数の範囲を使用できます。数値を一つ指定することは範囲「数値 .. 数値」を指定するのと同等です。忘れずに「..」の両側にスペースを入れてください（そうしないと範囲ではなく無効な浮動小数点数と誤解されます）。

追加：

SOFT、SOFTM、SOFTTは、動的テーブルを使用した場合に出力される項目の数を制御するプロパティです。上の例ではSOFTはUINT val3[val1]といった正規のフィールド向けです。SOFTMとSOFTTはMTX/MTX2/MTX3の内部を制御しています。 SOFTMはMAT/MAT2も制御します。

L2disasmは、指定されていない、または低すぎる場合、最初に通るフィールドを更新します。L2asmでは、MTX/MTX2/MTX3やMAT/MAT2や動的テーブルの項目のすべてにこれらのプロパティが設定されている必要があります。l2asm用のDDFファイルを簡単に生成するには、l2disasmの-eオプションを使用してください。

------------------------------------------------------------------------
2) 文字変換

DATファイルには2種類の文字列タイプがあります：

 - UCS-2LE unicode型（UTF-16のみ）
 - 8-bit / UCS-2LEのハイブリッド型（ASCIIとUTF-16のどちらもありうる）

L2disasmはこれらを常にUTF-8で保存します。

-lフラグを指定した場合、古いバージョンと類似した動作を強制します。この場合、文字列はほぼそのまま（いくつかの基本的な変換が実行される）UCS-2LEからASCIIに変換、または1文字づつASCIIからASCIIに保存されます。この動作はおそらく正しくないUTF-8を生成するため、l2asmの実行中、-lについて思い出してください。

動作モードにかかわらず、バックスラッシュ、タブ、NULL、CR、LFは、それぞれ\\、\t、\0、\r、\nとして保存されます。

ASCFはa,<string>またはu,<string>として保存されます。先頭のコード文字は、後でl2asmがASCFのエンコードを解釈する際のヒントです。

他に使用できるフラグは-fで、すべてのASCFの文字列を強制的に「a」ヒント付きで保存し（l2disasm）、どのようなヒントでも関係なく8ビットとしてエンコーディングします（l2asm）。非レガシーモードで動作した場合、通常l2asmは複雑な文字セット（漢字など）のプレーンな8ビットへの強制変換に失敗するので注意してください。

一般的には、-fは、1.05以前のバージョンと同様の結果を得るため、-lに追加して使用すべきです。

最後に、-aは8ビット文字をどのように解釈するかを選択できます。何も指定しない場合、デフォルトはISO-8859-1です。

--------------------------------------------------------------------------
3) コマンドオプション


l2disasm <-d DDFファイル> [-o f|e] [-q] [-e export] 入力ファイル 出力ファイル

-d は必須。入力ファイルと出力ファイルも同様

-e はオプション。整形され自動的にオプションが更新されたDDFファイルを出力します（l2asm用のSOFT*オプションに非常に有用）

-o はオプション。厳正な出力の「e」か標準の変動的な「f」のどちらか一つを選択します。「e」の出力は「より一層醜い」ですが、常に完璧な変換を保障します

-q HEADER制御変数を上書きし、ヘッダ行の出力を抑制します

-l 基本変換で「ダム」変換方式（ほぼそのまま出力）を使用します

-f すべてのASCFをヒント「a」付きで保存します

-a <chartab> 8ビット文字をどのように変換するか選択できます。デフォルトはISO-8859-1（ラテン文字）です



l2asm <-d DDFファイル> [-q] 入力ファイル 出力ファイル

-q HEADER変数を上書きします。l2asmはヘッダー行が存在しないと仮定します

-l 基本変換で「ダム」変換方式（ほぼそのまま出力）を使用します

-f すべてのASCF文字列を8ビット文字としてエンコードします

-a <chartab> 8ビット文字をどのように変換するか選択できます。デフォルトはISO-8859-1（ラテン文字）です


translated by gyo & google lol